<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">

        <!-- Enable responsiveness on mobile devices-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

        <title>Maik Klein</title>

        <!-- CSS -->
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/print.css" media="print">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/poole.css">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/lanyon.css">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.2/css/all.css" integrity="sha384-/rXc/GQVaYpyDdyxK+ecHPVYJSN9bmVFBvjA/9eOB+pb3F2w2N6fc5qB9Ew5yIns" crossorigin="anonymous">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/app.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous">
<script sync src="https://platform.twitter.com/widgets.js"></script>
<script>
  window.onload = (function(){

    var tweet = document.getElementById("tweet");
    var id = tweet.getAttribute("tweetID");

    twttr.widgets.createTweet(
      id, tweet, 
      {
        conversation : 'none',    // or all
        linkColor    : '#cc0000', // default is blue
        theme        : 'light',    // or dark
        align        : 'center'    
      })
    .then (function (el) {
      el.contentDocument.querySelector(".footer").style.display = "none";
    });

  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script>
        <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous"></script>
        <script src="https:&#x2F;&#x2F;maikklein.github.io/site.js"></script>
        

        
        
    <script>
        (function(d, s, id){
           var js, fjs = d.getElementsByTagName(s)[0];
           if (d.getElementById(id)) {return;}
           js = d.createElement(s); js.id = id;
           js.src = "https://assets.gfycat.com/gfycat.js";
           fjs.parentNode.insertBefore(js, fjs);
         }(document, 'script', 'gfycat-js'));
    </script>
    </head>

    <body>
        <div class="wrap">
            <div class="masthead">
                <div class="container">
                    <h3 class="masthead-title">
                        <a href="https:&#x2F;&#x2F;maikklein.github.io/" title="Home">Maik Klein</a>
                        <small>Blog</small>
                        <a href="https://github.com/maikklein" target="_blank"><i class="fab fa-github"></i></a>
                        <a href="https://twitter.com/MaikKlein_DEV" target="_blank"><i class="fab fa-twitter"></i></a>
                        <a href="https:&#x2F;&#x2F;maikklein.github.io/rss.xml" target="_blank"><i class="fas fa-rss"></i></a>
                        <a href="https://www.patreon.com/maikklein" target="_blank"><i class="fab fa-patreon"></i></a>
                    </h3>
                </div>
            </div>
        </div>
        <div class="content container">
            
<div class="post">
  <h1 class="post-title">Metaprogramming with type objects in D</h1>
  <span class="post-date">2016-03-01</span>
  <ul>
  
  </ul>
  <p>I am going to introduce you to <code>Type Objects</code> and why they might be useful in combination with metaprogramming.
This blog post is heavily inspired by <a href="https://github.com/boostorg/hana">Boost Hana</a>.</p>
<p>Let us start with an example. If we would want to implement an <code>Algebraic Data Type</code> we would need to find out the maximal size of the types it should contain. In D that is pretty easy</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">import std.meta: AliasSeq;
import std.traits: Largest;
alias Types = AliasSeq!(int, float, char, double);
enum maxSize = Largest!(Types).sizeof;
writeln(maxSize);&#x2F;&#x2F;8 bytes
</code></pre>
<p>Largest is implemented like this</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">template Largest(T...) if(T.length &gt;= 1)
{
    static if (T.length == 1)
    {
        alias Largest = T[0];
    }
    else static if (T.length == 2)
    {
        static if(T[0].sizeof &gt;= T[1].sizeof)
        {
            alias Largest = T[0];
        }
        else
        {
            alias Largest = T[1];
        }
    }
    else
    {
        alias Largest = Largest!(Largest!(T[0 .. $&#x2F;2]), Largest!(T[$&#x2F;2 .. $]));
    }
}
</code></pre>
<p>But if <code>Largest</code> wouldn't be available, it would be quite annoying to always create a new template. Alternatively we could implement <code>Largest</code> like this</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">import std.meta: AliasSeq, staticMap;
import std.traits: Largest;
import std.algorithm.comparison: max;
alias Types = AliasSeq!(int, float, char, double);
enum size(T) = T.sizeof;
enum maxSize = max(staticMap!(size, Types));
writeln(maxSize);&#x2F;&#x2F;8 byte
</code></pre>
<p>Not much worse because we can reuse the standard library but we also had to create a new template to convert types into sizes. This is a general pattern in metaprogramming. If you want to do type level metaprogramming you have to use templates but wouldn't it be nice if we could use ordinary functions?</p>
<p>Instead of doing type computations with templates we will create <code>Type Objects</code>.</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">import std.traits: isInstanceOf;
enum isType(T) = isInstanceOf!(Type, T);
struct Type(T){
    alias type = T;
    string toString()
    {
        return &quot;Type!(&quot;~T.stringof~&quot;)&quot;;
    }
}
</code></pre>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum t  = Type!(int)();
enum t1 = Type!(string)();
</code></pre>
<p>You may wonder why we do this. The answer is simple, we now can use <code>Types</code> like ordinary objects. Let us create a simple <code>equals</code> function that checks if two <code>Types</code> are actually the same.</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum equals(A,B)(Type!A, Type!B){
    return is(A == B);
}
enum t  = Type!(int)();
enum t1 = Type!(string)();

writeln(t.equals(t1)); &#x2F;&#x2F; false
writeln(equals(t, t1)); &#x2F;&#x2F; false
writeln(equals(Type!int(), Type!int())); &#x2F;&#x2F; true
</code></pre>
<p>Types itself are not that interesting, let us create a <code>TypeTuple</code> that can hold any number of <code>Types</code>.</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum isTypeTuple(T) = isInstanceOf!(TypeTuple, T);

struct TypeTuple(Types...){
    import std.meta: allSatisfy;
    static assert(allSatisfy!(isType, Types), &quot;Variadic parameters need to be of type &#x27;Type!&#x27;&quot;);
    Types expand;
    alias expand this;
    string toString()
    {
        import std.range;
        string[] s;
        foreach(t; expand){
            s~= t.toString();
        }
        return &quot;TypeTuple!(&quot; ~ s.join(&quot;, &quot;) ~&quot;)&quot;;
    }
}
enum typeTuple(Types...)(Types){
    return TypeTuple!Types();
}
</code></pre>
<p>By the way you may wonder why we created a <code>toString</code> method here. This is because <code>D</code> sometimes doesn't like to print types that were generated and it might not print the actual type and inserts some pseudo symbols like <code>F!int</code> instead of <code>Type!int</code>.</p>
<p>We can use <code>TypeTuple</code> like this:</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum types = TypeTuple!(Type!int, Type!char, Type!float, Type!double)();
&#x2F;&#x2F;or
enum types = typeTuple(Type!int, Type!char, Type!float, Type!double);
</code></pre>
<p>It is just a bit of boilerplate which we can easily avoid with a helper function</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum tupleFromTypes(Ts...)(){
    import std.meta: staticMap;
    return TypeTuple!(staticMap!(Type, Ts))();
}
enum types = tupleFromTypes!(int,double, int,float);
</code></pre>
<p>Now we can start to implement some nice metafunctions. We start by implementing <code>filter</code>.</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum filter(alias f, Tup)(Tup){
    static assert(isTypeTuple!(Tup), tup.stringof~&quot; is not a TypeTuple.&quot;);
    enum tup = Tup();
    static if(tup.length == 0){
        return typeTuple();
    }
    else static if(f(tup[0])){
        return typeTuple(tup[0], filter!(f)(typeTuple(tup[1..$])).expand);
    }
    else{
        return filter!(f)(typeTuple(tup[1..$]));
    }
}
</code></pre>
<p>We can now use it like this:</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum types = tupleFromTypes!(int, double, string, float);
enum biggerThan4 = filter!(t =&gt; t.type.sizeof &gt; 4)(types);
writeln(biggerThan4);&#x2F;&#x2F; TypeTuple!(Type!(double), Type!(string))
</code></pre>
<p>The code above filters our <code>TypeTuple</code> with an ordinary lambda function. The resulting <code>Types</code> must be bigger than 4 bytes. We can also implement <code>map</code></p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum map(alias f, Tup)(Tup){
    static assert(isTypeTuple!(Tup), tup.stringof~&quot; is not a TypeTuple.&quot;);
    enum tup = Tup();
    static if(tup.length == 0){
        return typeTuple!();
    }
    else{
        return typeTuple(f(tup[0]), map!(f)(typeTuple(tup[1..$])).expand);
    }
}
</code></pre>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum types = tupleFromTypes!(int, double, string, float);
enum onlyInts = map!(t =&gt; Type!int())(types);
writeln(onlyInts);&#x2F;&#x2F; TypeTuple!(Type!(int), Type!(int), Type!(int), Type!(int))
</code></pre>
<p>We replace every <code>Type</code> with <code>Type!int</code> which is probably not that useful. We could also replace only types that are actually bigger than 4 bytes with <code>Type!int</code>.</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum types = tupleFromTypes!(int, double, string, float);
enum smallerThan5 = map!((t){
    static if(t.type.sizeof &gt; 4){
        return Type!int();
    }
    else{
        return t;
    }
})(types);&#x2F;&#x2F; TypeTuple!(Type!(int), Type!(int), Type!(int), Type!(float))
writeln(smallerThan5);
</code></pre>
<p>The possibilities are almost endless and you can use it like any other function. Just remember that it needs to be executed at compile time which means you have to use <code>static if</code> instead of an ordinary <code>if</code>.</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum indexOf(T,Tup)(T, Tup){
    static assert(isTypeTuple!(Tup), tup.stringof~&quot; is not a TypeTuple.&quot;);
    static assert(isType!(T), T.stringof~&quot; is not a Type.&quot;);
    enum t = T();
    enum tup = Tup();
    foreach(index, type; tup.expand){
        if(type.equals(t)){
            return index;
        }
    }
    return -1;
}
enum types = tupleFromTypes!(int, double, string, float);
enum index = indexOf(Type!string(), types);
writeln(index);&#x2F;&#x2F; 2

</code></pre>
<p>And last but not least, we can implement quicksort for types.</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum partition(alias f, Tup)(Tup){
    enum tup = Tup();
    return partitionImpl!(f)(tup, typeTuple(), typeTuple());
}

enum partitionImpl(alias f, Tup, TupLeft, TupRight)(Tup, TupLeft, TupRight){
    import std.typecons: tuple;
    enum tup = Tup();
    enum l = TupLeft();
    enum r = TupRight();

    static if(tup.length == 0){
        return tuple(l, r);
    }
    else{
        static if(f(tup[0])){
            return partitionImpl!(f)(typeTuple(tup[1..$]), typeTuple(tup[0], l.expand), typeTuple(r.expand));
        }
        else{
            return partitionImpl!(f)(typeTuple(tup[1..$]), typeTuple(l.expand), typeTuple(tup[0], r.expand));
        }

    }
}

enum sort(alias f,Tup)(Tup){
    enum tup = Tup();
    static if(tup.length == 0){
        return typeTuple();
    }
    else static if(tup.length == 1){
        return typeTuple(tup[0]);
    }
    else{
        enum middle= tup[0];
        enum t = partition!(t =&gt; f(t, middle))(typeTuple(tup[1..$]));
        enum left = t[0];
        enum right = t[1];
        return typeTuple(left.expand, middle, right.expand);
    }
}
</code></pre>
<p>I needed to create another helper function <code>partition</code> which just splits a <code>TypeTuple</code> into two <code>TypeTuples</code> based on a predicate.</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum types = tupleFromTypes!(int, double, string, float);
enum sortedTypes = sort!((t1, t2) =&gt; t1.type.sizeof &gt; t2.type.sizeof)(types);
writeln(sortedTypes);&#x2F;&#x2F; TypeTuple!(Type!(string), Type!(double), Type!(int), Type!(float))
</code></pre>
<p>Now it is also trivial to get the maximum size</p>
<pre data-lang="d" class="language-d "><code class="language-d" data-lang="d">enum types = tupleFromTypes!(int, double, string, float);
enum sortedTypes = sort!((t1, t2) =&gt; t1.type.sizeof &gt; t2.type.sizeof)(types);
enum maxSize = sortedTypes[0].sizeof;
writeln(maxSize);&#x2F;&#x2F; 8 bytes
</code></pre>
<p><code>Type Objects</code> allow metaprogramming to look like normal functional programming just with types.</p>

</div>

            </div>


            <script>
             renderMathInElement(document.body,
                                 {
                                     delimiters: [
                                         {left: "$$", right: "$$", display: true},
                                         {left: "$", right: "$", display: false},
                                         {left: "\\[", right: "\\]", display: true}
                                     ],
                                 }
             );
            </script>
    </body>
</html>
