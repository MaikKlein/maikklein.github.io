<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">

        <!-- Enable responsiveness on mobile devices-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

        <title>Maik Klein</title>

        <!-- CSS -->
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/print.css" media="print">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/poole.css">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/lanyon.css">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.2/css/all.css" integrity="sha384-/rXc/GQVaYpyDdyxK+ecHPVYJSN9bmVFBvjA/9eOB+pb3F2w2N6fc5qB9Ew5yIns" crossorigin="anonymous">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/app.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous">
<script sync src="https://platform.twitter.com/widgets.js"></script>
<script>
  window.onload = (function(){

    var tweet = document.getElementById("tweet");
    var id = tweet.getAttribute("tweetID");

    twttr.widgets.createTweet(
      id, tweet, 
      {
        conversation : 'none',    // or all
        linkColor    : '#cc0000', // default is blue
        theme        : 'light',    // or dark
        align        : 'center'    
      })
    .then (function (el) {
      el.contentDocument.querySelector(".footer").style.display = "none";
    });

  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script>
        <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous"></script>
        <script src="https:&#x2F;&#x2F;maikklein.github.io/site.js"></script>
        

        
        
    <script>
        (function(d, s, id){
           var js, fjs = d.getElementsByTagName(s)[0];
           if (d.getElementById(id)) {return;}
           js = d.createElement(s); js.id = id;
           js.src = "https://assets.gfycat.com/gfycat.js";
           fjs.parentNode.insertBefore(js, fjs);
         }(document, 'script', 'gfycat-js'));
    </script>
    </head>

    <body>
        <div class="wrap">
            <div class="masthead">
                <div class="container">
                    <h3 class="masthead-title">
                        <a href="https:&#x2F;&#x2F;maikklein.github.io/" title="Home">Maik Klein</a>
                        <small>Blog</small>
                        <a href="https://github.com/maikklein" target="_blank"><i class="fab fa-github"></i></a>
                        <a href="https://twitter.com/MaikKlein_DEV" target="_blank"><i class="fab fa-twitter"></i></a>
                        <a href="https:&#x2F;&#x2F;maikklein.github.io/rss.xml" target="_blank"><i class="fas fa-rss"></i></a>
                        <a href="https://www.patreon.com/maikklein" target="_blank"><i class="fab fa-patreon"></i></a>
                    </h3>
                </div>
            </div>
        </div>
        <div class="content container">
            
<div class="post">
  <h1 class="post-title">First steps in Nom: Parsing pseudo GLSL</h1>
  <span class="post-date">2016-11-27</span>
  <ul>
  
  </ul>
  <p>I am currently working on my rendering engine and I always wanted to streamline my shader pipeline. I want to detect <code>.glsl</code> files, parse them, extract the type information and generate Rust bindings inside the build script.</p>
<p>GLSL can look like this:</p>
<pre data-lang="GLSL" class="language-GLSL "><code class="language-GLSL" data-lang="GLSL">#version 400
layout(location = 0) uniform vec4 color;
layout(location = 1) uniform mat4 mvp;

layout(location = 0) in vec4 pos;
in vec2 uv;

layout(location = 0) out vec3 test;
void main(){
    &#x2F;&#x2F;...
}
</code></pre>
<p>Here we have two <code>uniform</code> variables of type <code>vec4</code> and <code>mat4</code>, a <code>vec4</code> and a <code>vec2</code> as input and a <code>vec3</code> as output for a vertex shader.
Before today I had never really written any parser besides for CSV or OBJ and I was always scared of it because I know how complex they can get.
These are my first steps in Nom.</p>
<p>We are going to parse the <code>GLSL</code> code from above.
I started by defining an <code>enum</code>.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">#[derive(Debug)]
pub enum Glsl {
    Version(u32),
    Input(Option&lt;u32&gt;, String, String),
    Output(Option&lt;u32&gt;, String, String),
    Uniform(Option&lt;u32&gt;, String, String),
}
</code></pre>
<p>I just treat <code>Input</code>, <code>Output</code> and <code>Uniform</code> the same for now. There are edge cases that I just ignore for now for example we will not parse uniforms that are directly initialized nor array types.</p>
<p>We start by parsing the <code>Version</code>:</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">named!(glsl_version&lt;u32&gt;,
    do_parse!(
        tag!(&quot;#version&quot;) &gt;&gt;
        opt!(space) &gt;&gt;
        number: map_res!(
            digit,
            std::str::from_utf8
        ) &gt;&gt;
        opt!(multispace) &gt;&gt;
        (number.parse::&lt;u32&gt;().unwrap())
    )
);
</code></pre>
<p><code>glsl_version&lt;u32&gt;</code> will create a function with the name <code>glsl_version</code> and a return type of <code>u32</code>. We then look for a specific string that matches <code>#version</code>. It follows by 0 or more spaces which we express with <code>opt!(space)</code>, then we extract n characters that are digits into a variable called <code>number</code>. <code>multispace</code> recognizes spaces, tabs, carriage returns and line feeds. After that we parse the <code>number</code> into a <code>u32</code>. I call <code>.unwrap()</code> here because it shouldn't fail.</p>
<p>I will do something really hacky that you should probably never do in production code but it helps us to get started.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">named!(glsl_alt&lt;Option&lt;Glsl&gt;&gt;,
        alt!(
              glsl_version =&gt; { |n| Some(Glsl::Version(n)) }
            | take!(1) =&gt; { |_| None }
        )
);
</code></pre>
<p><code>alt!</code> is a conditional parser. It will try to execute the parser in order. If <code>glsl_version</code> fails we execute the <code>take!(1)</code> parser which consumes 1 byte and returns <code>None</code>. This is actually not the right place for <code>glsl_version</code> as the <code>#version</code> specifier should only occur at the top, but I will let it stay there for now.</p>
<p>This parser only executes once which in the case of <code>#version</code> would be enough but we still need to parse <code>in</code>, <code>out</code> and <code>uniform</code>.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">named!(parse_glsl&lt;&amp;[u8], Vec&lt;Option&lt;Glsl&gt;&gt; &gt;, many0!(glsl_alt));
</code></pre>
<p><code>many0</code> will execute the parser repeatedly and will write the results into a <code>Vec</code>.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">layout(location = 0) uniform vec4 color;
</code></pre>
<p>First we will write a parser for the optional layout specifier.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">named!(glsl_location&lt;u32&gt;,
    do_parse!(
        tag!(&quot;layout&quot;) &gt;&gt;
        opt!(space) &gt;&gt;
        tag!(&quot;(&quot;) &gt;&gt;
        opt!(space) &gt;&gt;
        tag!(&quot;location&quot;) &gt;&gt;
        opt!(space) &gt;&gt;
        tag!(&quot;=&quot;) &gt;&gt;
        opt!(space) &gt;&gt;
        location: map_res!(
            digit,
            std::str::from_utf8
        ) &gt;&gt;
        opt!(space) &gt;&gt;
        tag!(&quot;)&quot;) &gt;&gt;
        opt!(space) &gt;&gt;
        (location.parse::&lt;u32&gt;().unwrap())
    )
);
</code></pre>
<p>I am sure this could be written more elegantly but it should do the trick. It is very similar to the version parser. Because I pretend that <code>in</code>, <code>out</code> and <code>uniform</code> are the same we will create a macro that generates a parser to avoid code duplication.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">macro_rules! glsl_gen(
    ($name: ident, $i: expr) =&gt; (
        named!($name&lt;(Option&lt;u32&gt;, String, String)&gt;,
            do_parse!(
                location: opt!(glsl_location) &gt;&gt;
                tag!($i) &gt;&gt;
                opt!(space) &gt;&gt;
                type_name: map_res!(
                    alphanumeric,
                    std::str::from_utf8
                ) &gt;&gt;
                opt!(space) &gt;&gt;
                name: map_res!(
                    alphanumeric,
                    std::str::from_utf8
                ) &gt;&gt;
                opt!(space) &gt;&gt;
                char!(&#x27;;&#x27;) &gt;&gt;
                opt!(multispace) &gt;&gt;
                (location,
                 FromStr::from_str(type_name).unwrap(),
                 FromStr::from_str(name).unwrap())
            )
        );
    )
);

glsl_gen!(glsl_in, &quot;in&quot;);
glsl_gen!(glsl_out, &quot;out&quot;);
&#x2F;&#x2F;Note: Doesn&#x27;t parse if the uniform has a default initialization
glsl_gen!(glsl_uniform, &quot;uniform&quot;);
</code></pre>
<p>First we use the <code>glsl_location</code> parser that we just created and write the value into the variable <code>location</code>. <code>location</code> is of type <code>Option&lt;u32&gt;</code>. After that we basically do the same thing as we did in <code>glsl_version</code> and <code>glsl_location</code>. The only difference is that we return a tuple of type <code>(Option&lt;u32&gt;, String, String)</code>.</p>
<p>Now we can update <code>glsl_alt</code>.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">named!(glsl_alt&lt;Option&lt;Glsl&gt;&gt;,
        alt!(
              glsl_version =&gt; { |n| Some(Glsl::Version(n)) }
            | glsl_in =&gt; { |(loc, ty, name)| Some(Glsl::Input(loc, ty, name)) }
            | glsl_out =&gt; { |(loc, ty, name)| Some(Glsl::Output(loc, ty, name)) }
            | glsl_uniform =&gt; { |(loc, ty, name)| Some(Glsl::Uniform(loc, ty, name)) }
            | take!(1) =&gt; { |_| None }
        )
);
</code></pre>
<p>I hope you can see why I have written <code>glsl_alt</code> that way, it made it easy to get started but it comes with some problems. Every byte that fails to parse will add a <code>None</code> into a <code>Vec</code>.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">fn main() {
    let s = &quot;
        #version 400
        layout(location = 0) uniform vec4 color;
        layout(location = 1) uniform mat4 mvp;

        layout(location = 0) in vec4 pos;
        in vec2 uv;

        layout(location = 0) out vec3 test;
        void main(){
            &#x2F;&#x2F;...
        }
    &quot;;
    if let IResult::Done(_, o) = parse_glsl(s.as_bytes()){
        let v: Vec&lt;Glsl&gt; = o.into_iter().filter(|x| x.is_some()).map(|x| x.unwrap()).collect();
        println!(&quot;{:?}&quot;, v);
    }
}
</code></pre>
<p>For now I am just going to filter all those <code>None</code>'s.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">[Version(400),
 Uniform(Some(0), &quot;vec4&quot;, &quot;color&quot;),
 Uniform(Some(1), &quot;mat4&quot;, &quot;mvp&quot;),
 Input(Some(0), &quot;vec4&quot;, &quot;pos&quot;),
 Input(None, &quot;vec2&quot;, &quot;uv&quot;),
 Output(Some(0), &quot;vec3&quot;, &quot;test&quot;)]
</code></pre>
<p>For the first day of using <code>Nom</code> I call this a success, it was much easier than I thought. Obviously I completely ignored errors and edge cases and tons of other stuff but this is work for another day.</p>

</div>

            </div>


            <script>
             renderMathInElement(document.body,
                                 {
                                     delimiters: [
                                         {left: "$$", right: "$$", display: true},
                                         {left: "$", right: "$", display: false},
                                         {left: "\\[", right: "\\]", display: true}
                                     ],
                                 }
             );
            </script>
    </body>
</html>
