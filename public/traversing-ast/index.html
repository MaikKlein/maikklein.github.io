<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">

        <!-- Enable responsiveness on mobile devices-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

        <title>Maik Klein</title>

        <!-- CSS -->
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/print.css" media="print">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/poole.css">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/lanyon.css">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.2/css/all.css" integrity="sha384-/rXc/GQVaYpyDdyxK+ecHPVYJSN9bmVFBvjA/9eOB+pb3F2w2N6fc5qB9Ew5yIns" crossorigin="anonymous">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/app.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous">
<script sync src="https://platform.twitter.com/widgets.js"></script>
<script>
  window.onload = (function(){

    var tweet = document.getElementById("tweet");
    var id = tweet.getAttribute("tweetID");

    twttr.widgets.createTweet(
      id, tweet, 
      {
        conversation : 'none',    // or all
        linkColor    : '#cc0000', // default is blue
        theme        : 'light',    // or dark
        align        : 'center'    
      })
    .then (function (el) {
      el.contentDocument.querySelector(".footer").style.display = "none";
    });

  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script>
        <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous"></script>
        <script src="https:&#x2F;&#x2F;maikklein.github.io/site.js"></script>
        

        
        
    <script>
        (function(d, s, id){
           var js, fjs = d.getElementsByTagName(s)[0];
           if (d.getElementById(id)) {return;}
           js = d.createElement(s); js.id = id;
           js.src = "https://assets.gfycat.com/gfycat.js";
           fjs.parentNode.insertBefore(js, fjs);
         }(document, 'script', 'gfycat-js'));
    </script>
    </head>

    <body>
        <div class="wrap">
            <div class="masthead">
                <div class="container">
                    <h3 class="masthead-title">
                        <a href="https:&#x2F;&#x2F;maikklein.github.io/" title="Home">Maik Klein</a>
                        <small>Blog</small>
                        <a href="https://github.com/maikklein" target="_blank"><i class="fab fa-github"></i></a>
                        <a href="https://twitter.com/MaikKlein_DEV" target="_blank"><i class="fab fa-twitter"></i></a>
                        <a href="https:&#x2F;&#x2F;maikklein.github.io/rss.xml" target="_blank"><i class="fas fa-rss"></i></a>
                        <a href="https://www.patreon.com/maikklein" target="_blank"><i class="fab fa-patreon"></i></a>
                    </h3>
                </div>
            </div>
        </div>
        <div class="content container">
            
<div class="post">
  <h1 class="post-title">AST traversal and code generation</h1>
  <span class="post-date">2017-08-20</span>
  <ul>
  
  </ul>
  <p><a href="https://maikklein.github.io/post/shading-language-part1/">Previous blog post</a> </p>
<p>In this blog post I will mainly talk about AST traversal and code generation and the problems that I am currently facing.</p>
<p>What is AST traversal? </p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">#[derive(Debug)]
enum Expr&lt;&#x27;a&gt; {
    Num(i32),
    Add(&amp;&#x27;a Expr&lt;&#x27;a&gt;, &amp;&#x27;a Expr&lt;&#x27;a&gt;),
    Mul(&amp;&#x27;a Expr&lt;&#x27;a&gt;, &amp;&#x27;a Expr&lt;&#x27;a&gt;),
}

fn fold_expr&lt;T, Unary: Fn(i32) -&gt; T, Add: Fn(T, T) -&gt; T, Mul: Fn(T, T) -&gt; T&gt;(
    unary: &amp;Unary,
    add: &amp;Add,
    mul: &amp;Mul,
    e: &amp;Expr,
) -&gt; T {
    let rec = |e: &amp;Expr| fold_expr(unary, add, mul, e);
    match e {
        &amp;Expr::Num(i) =&gt; unary(i),
        &amp;Expr::Add(l, r) =&gt; add(rec(l), rec(r)),
        &amp;Expr::Mul(l, r) =&gt; mul(rec(l), rec(r)),
    }
}

fn main() {
    let eval = |e: &amp;Expr| fold_expr(&amp;|a| a, &amp;|a, b| a + b, &amp;|a, b| a * b, e);
    let e = Expr::Add(&amp;Expr::Num(5), &amp;Expr::Mul(&amp;Expr::Num(10), &amp;Expr::Num(5)));
    println!(&quot;{:?}&quot;, eval(&amp;e));
}
</code></pre>
<p><a href="https://play.rust-lang.org/?gist=5f24062414040aca65ae33a3e1dfbc06&amp;version=nightly">Playground</a></p>
<p>Here we create a small AST, and then we <code>fold</code> it into a single value. I translated this directly from some Haskell code that I found a few days ago. While this is not completely idiomatic Rust, it didn't translate too badly. An alternative to this traversal is traversal with the visitor pattern. This is how the visitor pattern looks currently in Rust</p>
<p><a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/visit.rs#L52">visit.rs</a></p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">pub trait Visitor&lt;&#x27;ast&gt;: Sized {
    ...
    fn visit_local(&amp;mut self, l: &amp;&#x27;ast Local) { walk_local(self, l) }
    fn visit_mod(&amp;mut self, m: &amp;&#x27;ast Mod, _s: Span, _attrs: &amp;[Attribute], _n: NodeId) {
        walk_mod(self, m);
    }
    ...
}
pub fn walk_mod&lt;&#x27;a, V: Visitor&lt;&#x27;a&gt;&gt;(visitor: &amp;mut V, module: &amp;&#x27;a Mod) {
    walk_list!(visitor, visit_item, &amp;module.items);
}

pub fn walk_local&lt;&#x27;a, V: Visitor&lt;&#x27;a&gt;&gt;(visitor: &amp;mut V, local: &amp;&#x27;a Local) {
    for attr in local.attrs.iter() {
        visitor.visit_attribute(attr);
    }
    visitor.visit_pat(&amp;local.pat);
    walk_list!(visitor, visit_ty, &amp;local.ty);
    walk_list!(visitor, visit_expr, &amp;local.init);
}


</code></pre>
<p>Every function inside the trait has a default implementation with a walk function. This means that if you want to implement your own <code>Visitor</code> you only have to overwrite the functions that you are interested in. And when you want to overwrite a function, you can reuse the walk functions. I think this is actually a really nice pattern but I had a few practical problems with it.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">fn visit_assign(&amp;mut self, stmt: &amp;&#x27;a Stmt&lt;&#x27;a&gt;, assign: &amp;&#x27;a Assign&lt;&#x27;a&gt;, data: &amp;Self::Data) {
    walk_assign(self, stmt, assign, data);
    let spirv_expr = self.ctx.spirv_expr.get(&amp;assign.expr.node_id).expect(&quot;expr&quot;);
    let var_def = self.ctx
        .scopes
        .get_var_def(&amp;stmt.node_id, &amp;assign.ident)
        .expect(&quot;no var def&quot;);
    let spirv_var = self.ctx.spirv_var.get(&amp;var_def.node_id).expect(
        &quot;no spirv var&quot;,
    );
    self.ctx.builder.store(
        spirv_var.var_id,
        *spirv_expr,
        None,
        &amp;[],
    );
}
pub fn walk_assign&lt;&#x27;a, V: Visitor&lt;&#x27;a&gt;&gt;(
    visitor: &amp;mut V,
    stmt: &amp;&#x27;a Stmt&lt;&#x27;a&gt;,
    assign: &amp;&#x27;a Assign&lt;&#x27;a&gt;,
    data: &amp;V::Data,
) {
    visitor.visit_expr(&amp;assign.expr, data);
}
</code></pre>
<p>This is code from from my spirv compiler. Essentially it generates spirv for assignments <code>a = 4;</code>. On the left side is a variable with a name, which we need to find. On the right side is an expression which need to evaluate before we can generate the code for the assignment. This is why I call <code>walk_assign</code> at the top. The problem is that this visitor can not return values directly. I currently put the results in a <code>VecMap</code> which is like a hash map, but more efficient for numbers that are close together.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">walk_assign(self, stmt, assign, data);
let spirv_expr = self.ctx.spirv_expr.get(&amp;assign.expr.node_id).expect(&quot;expr&quot;);
</code></pre>
<p>There are a few problems, first we have to write the result into some container which means that the lookup could fail and it makes multi-threading more painful than it needs to be. </p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">extern crate rayon;

#[derive(Debug)]
pub enum Expr&lt;&#x27;a&gt; {
    Num(i32),
    Add(&amp;&#x27;a Expr&lt;&#x27;a&gt;, &amp;&#x27;a Expr&lt;&#x27;a&gt;),
    Mul(&amp;&#x27;a Expr&lt;&#x27;a&gt;, &amp;&#x27;a Expr&lt;&#x27;a&gt;),
}

pub trait Visitor&lt;&#x27;a&gt;: Sized + Sync {
    type R: Send;
    fn visit_expr(&amp;self, e: &amp;&#x27;a Expr&lt;&#x27;a&gt;) -&gt; Self::R {
        walk_expr(self, e)
    }
    fn visit_mul(&amp;self, l: &amp;&#x27;a Expr&lt;&#x27;a&gt;, r: &amp;&#x27;a Expr&lt;&#x27;a&gt;) -&gt; Self::R;
    fn visit_add(&amp;self, l: &amp;&#x27;a Expr&lt;&#x27;a&gt;, r: &amp;&#x27;a Expr&lt;&#x27;a&gt;) -&gt; Self::R;
    fn visit_num(&amp;self, i: i32) -&gt; Self::R;
}

pub fn walk_expr&lt;&#x27;a, V: Visitor&lt;&#x27;a&gt;&gt;(v: &amp;V, e: &amp;&#x27;a Expr&lt;&#x27;a&gt;) -&gt; V::R {
    &#x2F;&#x2F; Maybe use join here?
    let mut r: Option&lt;V::R&gt; = None;
    rayon::scope(|scope| {
        scope.spawn(|_| {
            r = Some(match e {
                &amp;Expr::Add(l, r) =&gt; v.visit_add(l, r),
                &amp;Expr::Mul(l, r) =&gt; v.visit_mul(l, r),
                &amp;Expr::Num(i) =&gt; v.visit_num(i),
            })
        });
    });
    r.unwrap()
}

pub fn walk_add&lt;&#x27;a, V: Visitor&lt;&#x27;a&gt;&gt;(v: &amp;V, l: &amp;&#x27;a Expr&lt;&#x27;a&gt;, r: &amp;&#x27;a Expr&lt;&#x27;a&gt;) -&gt; (V::R, V::R) {
    rayon::join(|| v.visit_expr(l), || v.visit_expr(r))
}

pub fn walk_mul&lt;&#x27;a, V: Visitor&lt;&#x27;a&gt;&gt;(v: &amp;V, l: &amp;&#x27;a Expr&lt;&#x27;a&gt;, r: &amp;&#x27;a Expr&lt;&#x27;a&gt;) -&gt; (V::R, V::R) {
    rayon::join(|| v.visit_expr(l), || v.visit_expr(r))
}

pub struct FoldVisitor;

pub fn fold_expr&lt;&#x27;a, &#x27;b&gt;(e: &amp;&#x27;a Expr&lt;&#x27;b&gt;) -&gt; i32 {
    let f = FoldVisitor {};
    FoldVisitor::visit_expr(&amp;f, e)
}

impl&lt;&#x27;a&gt; Visitor&lt;&#x27;a&gt; for FoldVisitor {
    type R = i32;
    fn visit_mul(&amp;self, l: &amp;&#x27;a Expr&lt;&#x27;a&gt;, r: &amp;&#x27;a Expr&lt;&#x27;a&gt;) -&gt; Self::R {
        let (l, r) = walk_add(self, l, r);
        l * r
    }

    fn visit_add(&amp;self, l: &amp;&#x27;a Expr&lt;&#x27;a&gt;, r: &amp;&#x27;a Expr&lt;&#x27;a&gt;) -&gt; Self::R {
        let (l, r) = walk_add(self, l, r);
        l + r
    }

    fn visit_num(&amp;self, i: i32) -&gt; Self::R {
        i
    }
}

fn main() {
    let e = Expr::Mul(&amp;Expr::Num(5), &amp;Expr::Add(&amp;Expr::Num(10), &amp;Expr::Num(5)));
    println!(&quot;{:?}&quot;, fold_expr(&amp;e));
}
</code></pre>
<p>Essentially two things changed. The visitor is now borrowed immutably, every function now has an explicit return and most visit functions have no default implementation anymore. Also the walk functions can now be paralellized. I decided to use rayon because it easy to use and it almost does what I want.</p>
<p>For me it is important that the compiler is designed from the ground up to support multi-threading, as it would most likely not be easy to add it later.</p>
<p>The main problem with this example is that it is too simple. </p>
<p>Consider this let statement.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">let a: Bar = foo();
</code></pre>
<p>Before we can typecheck this expression we need to find the correct function <code>foo</code> as there could be many more functions named <code>foo</code> in different scopes. Then we need to extract the return type, which is a user defined type. This means that we also have to find that type in the correct scope. Also <code>Bar</code> can be defined after <code>foo</code>.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">fn foo() -&gt; Bar{
    Bar{}
}
struct Bar; 
</code></pre>
<p>Because of this, we need to collect information about the AST before we can do type checking. The same is true for code generation</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">let a = 4;
let b = a;
</code></pre>
<p>We first create a new variable and store the value <code>4</code> in <code>a</code>, then we create variable <code>b</code> and load the value of <code>a</code> and store it in <code>b</code>. This is the equivalent SPIR-V code.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust"> %a = OpVariable %_ptr_Function_uint Function
      OpStore %a %uint_4
 %b = OpVariable %_ptr_Function_uint Function
%20 = OpLoad %uint %a
      OpStore %b %20
</code></pre>
<p>This means that when we traverse the AST and generate code for <code>a</code>, we need to reuse the symbols that we generated previously. To me this seems like an inherently mutable problem (at least in Rust). I am not sure if and immutable solution would be a viable approach in Rust. I am thinking of using a <a href="https://docs.rs/chashmap/2.2.0/chashmap/">concurrent hashmap</a> unless I can think of a better solution.</p>
<p>The other problem is the code generation itself. I currently have one mutable builder object that can record instructions.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">self.ctx.builder.store(
    spirv_var.var_id,
    *spirv_expr,
    None,
    &amp;[],
);
</code></pre>
<p>Of course I can not use this in multi-threaded code. I could wrap in a <code>Mutex</code> but that would completely kill the performance as this object is accessed in every node inside the AST. One solution that I am thinking of is to create a separate builder object in every traversal, record commands and return the object. Then I could stitch those objects together when I traverse the AST from the bottom to the top. The caveat is that this would introduce many small allocations and Rust currently doesn't really have good solution for memory management with user defined allocators.</p>
<p>Traversing the AST turned out to be harder than I thought but I think the visitor pattern with explicit returns will result in cleaner and better code.</p>

</div>

            </div>


            <script>
             renderMathInElement(document.body,
                                 {
                                     delimiters: [
                                         {left: "$$", right: "$$", display: true},
                                         {left: "$", right: "$", display: false},
                                         {left: "\\[", right: "\\]", display: true}
                                     ],
                                 }
             );
            </script>
    </body>
</html>
