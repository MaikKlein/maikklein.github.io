<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">

        <!-- Enable responsiveness on mobile devices-->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

        <title>Maik Klein</title>

        <!-- CSS -->
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/print.css" media="print">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/poole.css">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/lanyon.css">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.2/css/all.css" integrity="sha384-/rXc/GQVaYpyDdyxK+ecHPVYJSN9bmVFBvjA/9eOB+pb3F2w2N6fc5qB9Ew5yIns" crossorigin="anonymous">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;maikklein.github.io/app.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" integrity="sha384-exe4Ak6B0EoJI0ogGxjJ8rn+RN3ftPnEQrGwX59KTCl5ybGzvHGKjhPKk/KC3abb" crossorigin="anonymous">
<script sync src="https://platform.twitter.com/widgets.js"></script>
<script>
  window.onload = (function(){

    var tweet = document.getElementById("tweet");
    var id = tweet.getAttribute("tweetID");

    twttr.widgets.createTweet(
      id, tweet, 
      {
        conversation : 'none',    // or all
        linkColor    : '#cc0000', // default is blue
        theme        : 'light',    // or dark
        align        : 'center'    
      })
    .then (function (el) {
      el.contentDocument.querySelector(".footer").style.display = "none";
    });

  });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" integrity="sha384-OMvkZ24ANLwviZR2lVq8ujbE/bUO8IR1FdBrKLQBI14Gq5Xp/lksIccGkmKL8m+h" crossorigin="anonymous"></script>
        <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous"></script>
        <script src="https:&#x2F;&#x2F;maikklein.github.io/site.js"></script>
        

        
        
    <script>
        (function(d, s, id){
           var js, fjs = d.getElementsByTagName(s)[0];
           if (d.getElementById(id)) {return;}
           js = d.createElement(s); js.id = id;
           js.src = "https://assets.gfycat.com/gfycat.js";
           fjs.parentNode.insertBefore(js, fjs);
         }(document, 'script', 'gfycat-js'));
    </script>
    </head>

    <body>
        <div class="wrap">
            <div class="masthead">
                <div class="container">
                    <h3 class="masthead-title">
                        <a href="https:&#x2F;&#x2F;maikklein.github.io/" title="Home">Maik Klein</a>
                        <small>Blog</small>
                        <a href="https://github.com/maikklein" target="_blank"><i class="fab fa-github"></i></a>
                        <a href="https://twitter.com/MaikKlein_DEV" target="_blank"><i class="fab fa-twitter"></i></a>
                        <a href="https:&#x2F;&#x2F;maikklein.github.io/rss.xml" target="_blank"><i class="fas fa-rss"></i></a>
                        <a href="https://www.patreon.com/maikklein" target="_blank"><i class="fab fa-patreon"></i></a>
                    </h3>
                </div>
            </div>
        </div>
        <div class="content container">
            
<div class="post">
  <h1 class="post-title">SoA in Rust with Macros 1.1</h1>
  <span class="post-date">2017-01-03</span>
  <ul>
  
      <li>
          <a href="#soa">SoA</a>
          
      </li>
  
      <li>
          <a href="#macros-1-1">Macros 1.1</a>
          
          <ul>
              
              <li>
                  <a href="#update1">Update1:</a>
              </li>
              
          </ul>
          
      </li>
  
  </ul>
  <p><em>Disclaimer</em>: This is just a proof of concept.</p>
<h2 id="soa">SoA</h2>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">#![feature(proc_macro)]
#[macro_use]
extern crate soa_derive;

#[derive(Debug)]
struct Vec2{
    x: f32,
    y: f32
}

impl Vec2{
    pub fn new() -&gt; Self{
        Vec2{
            x: 0.0,
            y: 0.0
        }
    }
}

#[derive(SoA)]
struct GameObject {
    pos: Vec2,
    vel: Vec2,
    health: f32,
    &#x2F;&#x2F; Other fields . . .
}

fn main() {
    let mut soa = GameObjectSoA::new();
    let game_object = GameObject {
        pos: Vec2::new(),
        vel: Vec2::new(),
        health: 42.0,
    };
    soa.push(game_object);
    println!(&quot;{:?}&quot;, soa);
}
</code></pre>
<p>Let us have a look at the generated code.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">#[derive(Debug)]
struct GameObjectSoA {
    pub pos: Vec&lt;Vec2&gt;,
    pub vel: Vec&lt;Vec2&gt;,
    pub health: Vec&lt;f32&gt;,
}
impl GameObjectSoA {
    pub fn new() -&gt; Self {
        GameObjectSoA {
            pos: Vec::new(),
            vel: Vec::new(),
            health: Vec::new(),
        }
    }
    pub fn push(&amp;mut self, value: GameObject) {
        let GameObject { pos: pos, vel: vel, health: health } = value;
        self.pos.push(pos);
        self.vel.push(vel);
        self.health.push(health);
    }
}
</code></pre>
<p><code>soa_derive</code> essentially turns a struct of fields into a struct of arrays.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">&#x2F;&#x2F; aos = array of structures
let mut aos = Vec::&lt;GameObject&gt;::new();
&#x2F;&#x2F; soa = structure of arrays
let mut soa = GameObjectSoA::new();
</code></pre>
<p>You might ask yourself, &quot;Why is this useful?&quot;. The answer is mainly for performance. Often when you want to iterate over a <code>Vec&lt;GameObject&gt;</code>, you don't actually care about every field. For example you might just want to adjust the <code>health</code> of every <code>GameObject</code>. For AoS that means that you will needlessly load a lot of data into your cache that you actually never use. Of course AoS is still useful for data that you want to access together for example <code>Vec&lt;Vec2&gt;</code>.</p>
<p>The nice thing about <code>soa_derive</code> is that the usage is very similar to AoS.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">&#x2F;&#x2F; SoA
let mut soa = GameObjectSoA::new();
let game_object = GameObject {
    pos: Vec2::new(),
    vel: Vec2::new(),
    health: 42.0,
};
soa.push(game_object);
</code></pre>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">&#x2F;&#x2F; AoS
let mut aos = Vec::&lt;GameObject&gt;::new();
let game_object = GameObject {
    pos: Vec2::new(),
    vel: Vec2::new(),
    health: 42.0,
};
aos.push(game_object);
</code></pre>
<p>You can find the code <a href="https://github.com/MaikKlein/soa_derive">here</a>. It is nothing more than a proof of concept.</p>
<h2 id="macros-1-1">Macros 1.1</h2>
<p>Overall I really like Macros 1.1 but there are a few things that are a bit awkward. For example generating the push method:</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">pub fn push(&amp;mut self, value: GameObject) {
    let GameObject { pos: pos, vel: vel, health: health } = value;
    self.pos.push(pos);
    self.vel.push(vel);
    self.health.push(health);
}
</code></pre>
<p>And specifically this line</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">let GameObject { pos: pos, vel: vel, health: health } = value;
</code></pre>
<p>I think the limitations of <code>quote!</code> are that you can only interpolate something that implements <code>ToTokens</code> and you can only use it one time.</p>
<p>The following code does not compile</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">let fields: Vec&lt;Field&gt; = ...;
let field_idents: Vec&lt;Ident&gt; = fields.iter().map(|f| f.ident.clone().unwrap()).collect();
quote!{
    impl #soa_ident {
        pub fn push(&amp;mut self, value: #ident){
            let #ident{#(#field_idents: #field_idents, )*} = value;
            #(
               self.#field_idents.push(#field_idents);
            )*
        }
    }
}
</code></pre>
<p>I had to write it like this</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">let field_idents: Vec&lt;Ident&gt; = fields.iter().map(|f| f.ident.clone().unwrap()).collect();
let push_self: Vec&lt;quote::Tokens&gt; = fields.iter()
    .map(|f| {
        let field = f.ident.clone().unwrap();
        quote!{
            self.#field.push(#field);
        }
    })
    .collect();
let deconstruct_list: Vec&lt;quote::Tokens&gt; = fields.iter()
    .map(|f| {
        let field = f.ident.clone().unwrap();
        quote!{
            #field: #field
        }
    })
    .collect();

quote!{
    impl #soa_ident {
        pub fn push(&amp;mut self, value: #ident){
            let #ident{#(#deconstruct_list, )*} = value;
            #(
                #push_self
            )*
        }
    }
}
</code></pre>
<p>Essentially I had to create a new loop that would exactly output the thing that I wanted.</p>
<p>What I really wanted to write would be something like this</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">&#x2F;&#x2F; Pseudo code
&#x2F;&#x2F; For readability I didn&#x27;t handle the option case.
let fields: Vec&lt;Field&gt; = ...;
quote!{
    impl #soa_ident {
        pub fn push(&amp;mut self, value: #ident){
            let #ident{#(#[fields.ident]: #[fields.ident], )*} = value;
            #(
               self.#[fields.ident].push(#[fields.ident]);
            )*
        }
    }
}
</code></pre>
<p>Instead of directly interpolating on values that implement <code>ToTokens</code>, only the &quot;expressions&quot; would have to require <code>ToTokens</code>. Here the expression would be #[field.ident]. I am not sure if that could be implemented but it would essentially get rid of all the temporary <code>Vec</code>'s that you have to create to get the correct output.</p>
<p>What I really like this that the generated code is just a string which you can just print to the console. Of course it is barely readable because everything will be on the same line but you can just format the string with <code>rustfmt</code>.</p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">#[proc_macro_derive(SoA)]
pub fn soa_derive(input: TokenStream) -&gt; TokenStream {
    let s = input.to_string();
    let ast = syn::parse_macro_input(&amp;s).unwrap();
    let gen = gen_soa_derive(&amp;ast);
    &#x2F;&#x2F; Displays the generated code
    println!(&quot;{}&quot;, gen);
    gen.parse().unwrap()
}
</code></pre>
<p>And if you are curious this is how the push method would look in <code>D</code>.
<a href="https://maikklein.github.io/post/soa-d/">Blog post</a></p>
<pre data-lang="D" class="language-D "><code class="language-D" data-lang="D">void insertBack(T t){
    if(length == size) grow;
    foreach(index, _; Types){
        containers[index][length] = __traits(getMember, t, MemberNames[index]);
    }
    length = length + 1;
}
</code></pre>
<h3 id="update1">Update1:</h3>
<p>There is actually a workaround for accessing the same iterator multiple times in a <code>quote!</code>.<a href="https://www.reddit.com/r/rust/comments/5lrb9y/soa_in_rust_with_macros_11/dbxwfy7/">Source</a></p>
<pre data-lang="Rust" class="language-Rust "><code class="language-Rust" data-lang="Rust">let field_idents_: Vec&lt;Ident&gt; = fields.iter().map(|f| f.ident.clone().unwrap()).collect();
let field_idents = &amp;field_idents_;
let field_idents1= &amp;field_idents_;

quote!{
    #[derive(Debug)]
    struct #soa_ident {
        #(
            #vec_fields,
        )*
    }
    impl #soa_ident {
        pub fn new() -&gt; Self {
            #soa_ident {
                #(
                    #field_idents : Vec::new(),
                )*
            }
        }

        pub fn push(&amp;mut self, value: #ident){
            let #ident{#(#field_idents: #field_idents1, )*} = value;
            #(
                self.#field_idents.push(#field_idents1);
            )*
        }
    }
}
</code></pre>

</div>

            </div>


            <script>
             renderMathInElement(document.body,
                                 {
                                     delimiters: [
                                         {left: "$$", right: "$$", display: true},
                                         {left: "$", right: "$", display: false},
                                         {left: "\\[", right: "\\]", display: true}
                                     ],
                                 }
             );
            </script>
    </body>
</html>
